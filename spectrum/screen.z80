; ----------------------------------------------------------------------
; Screen manipulation routines for the Spectrum
; ----------------------------------------------------------------------

vCharPos:                       ; row, col coordinates in our 40x24 screen
vCharPosX:  defb 0              ; column
vCharPosY:  defb 0              ; row
vCharTemp:  defw 0,0,0,0        ; 8 bytes to hold generated characters, e.g. graphics or double height
vduBuffCmd: defb 0              ; Byte invoking vduBuffer
vduBuffPos: defb 0              ; Position in vduBuffer, 0=empty
vduBuffer:  defw 0,0,0,0,0      ; 10 byte buffer for vdu sequences

clearScreen:
    ld      hl,&4000            ; Start of screen memory
    ld      (hl),&00            ; Set first byte to 0
    ld      de,&4001            ; Destination as next byte
    ld      bc, 32*24*8-1       ; Number of bytes to copy
    ldir                        ; Copy from hl to de bc times

    ld      hl,&5800            ; Reset screen attributes
    ld      (hl),&07            ; White text black Background
    ld      de,&5801
    ld      bc, 32*24-1         ; Bytes to copy
    ldir

    ld      a,0                 ; Set border to black
    ld      (&5C48),a           ; set OS copy of colour
    out     (&fe),a             ; set hardware colour

    ld      a,0                 ; reset state
    ld      (vduBuffPos),a

teletextHome:                   ; Home cursor to 0,0
    ld      bc, 0

setPos:                         ; Set cursor to bc (row, col)
    ld      (vCharPos),bc       ; Store in vCharPos
    ret

; Calculates the actual bitmap address for a character in BC (row,col) into HL.
;
; Although the memory map for the spectrum screen seems weird with it's layout,
; it's actually pretty logical. You can tell this weirdness is down to how the ULA works internally.
;
; Address format:
;           H       L
;       010rrnnn rrrccccc       where r=row, c=column & n is the byte of the character definition.
;
; So, to calculate the address of a character
;       High byte = &40 or (row and &18)
;       Low byte  = (row<<5) or column
;
; That would then be the top byte of the character. To get the next byte just increment the high byte
; (e.g. n=1) & so on.
;
getSpectrumCharPos:             ; Get Spectrum char pos (bc) into HL for physical screen address
    ld      a, b                ; first calculate high byte - get row
    and     &18                 ; Mask bits 4 & 5 from row
    or      &40                 ; set bit 6, this gives us the upper memory address
    ld      h, a                ; Set H

    ld      a, b                ; get row
    sla     a                   ; Shift left 5 to form low address
    sla     a
    sla     a
    sla     a
    sla     a                   ; HA is now the address of the start of line

    or      c                   ; Add column value
    ld      l, a                ; HL now address of top row of character

    ret

; Given an ascii char 32..127 in A return the address of the bitmap definition for that character in HL
getCharDef:                 ; Set's HL to be the character definition in A
    sub     32              ; char set starts with space
    ld      l,a             ; Set L to A
    ld      h,0             ; Clear H
    sla     l               ; Shift left 3 times so hl = a*8
    rl      h
    sla     l
    rl      h
    sla     l
    rl      h
    ld      bc, charset     ; Add charset base
    add     hl, bc
    ret

; With a character definition in DE, write the character at position vCharPos (40x24)
; handling any conversion to the Spectrum's 32x24 screen
wrchr:
    ld      bc, (vCharPos)      ; Get char position in 40x24 coordinates
    srl     c                   ; Divide column by 4
    srl     c
    ld      a,c                 ; A=c
    add     a,c
    add     a,c                 ; A = 3 * c
    ld      c,a                 ; C is now int(c*3/4) so points to start of the 3 char block
    call    getSpectrumCharPos  ; convert BC (now in 32x24 coords) into HL

    ld      b, 8                ; Set b as counter of 8 bytes to copy

    ld      a, (vCharPosX)      ; Now work out which char we are working on
    bit     1,a
    jr      nz, wrchr23         ; Chars 2 or 3
    bit     0,a                 ; Test we are char 0 or 1
    jr      nz, wrchr1          ; Char 1

wrchr0:                         ; Write char 0 in the block
    ld      a,(hl)              ; char is split across 2 bytes so byte 0
    and     &03                 ; mask out space for new char
    ld      c,a                 ; save in c
    ld      a, (de)             ; Get char definition
    sla     a                   ; Shift left 2
    sla     a
    or      c                   ; bring in next char in bottom 2 bits
    ld      (hl),a              ; store on screen
    inc     h                   ; next pixel line down
    inc     de
    djnz    wrchr0
    ret

wrchr1:                         ; write char 1 in the block
    ld      a,(hl)              ; first byte bottom 2 bits are high 2 bits of char
    and     &fc                 ; mask out those bits
    ld      c,a
    ld      a, (de)             ; char definition
    srl     a                   ; shift right 4 so we have just the top 2 bits
    srl     a
    srl     a
    srl     a
    or      c
    ld      (hl),a              ; Update screen

    inc     l                   ; now for byte 1
    ld      a,(hl)
    and     &0f                 ; mask out space for new char
    ld      c,a                 ; save in c
    ld      a, (de)             ; Get char definition
    sla     a                   ; Shift left 4
    sla     a
    sla     a
    sla     a
    or      c                   ; bring in next char in bottom 4 bits
    ld      (hl),a              ; store on screen
    dec     l                   ; restore l for next row

    inc     h
    inc     de
    djnz    wrchr1
    ret

wrchr23:                        ; See if we are char 2 or 3
    bit     0,a
    jr      nz, wrchr3          ; Char 3

wrchr2:                         ; write char 2 in the block
    inc     l                   ; Starts in byte 1
wrchr21:
    ld      a,(hl)              ; second byte bottom 4 bits are high 4 bits of char
    and     &f0                 ; mask out those bits
    ld      c,a
    ld      a, (de)             ; char definition
    srl     a                   ; shift right 2 so we have just the top 4 bits
    srl     a
    or      c
    ld      (hl),a              ; Update screen

    inc     l                   ; now for byte 1
    ld      a,(hl)
    and     &3f                 ; mask out space for new char
    ld      c,a                 ; save in c
    ld      a, (de)             ; Get char definition
    sla     a                   ; Shift left 6
    sla     a
    sla     a
    sla     a
    sla     a
    sla     a
    or      c                   ; bring in next char in bottom 4 bits
    ld      (hl),a              ; store on screen
    dec     l                   ; restore l for next row

    inc     h
    inc     de
    djnz    wrchr21
    ret

wrchr3:                         ; Write char 3 in the block
    inc     l                   ; Work on byte 2 only
    inc     l
wrchr31:
    ld      a, (hl)
    and     &c0                 ; mask out space for new char
    ld      c,a                 ; save in c
    ld      a, (de)             ; char definition
    or      c                   ; bring in prev char in top 2 bits
    ld      (hl),a              ; store on screen
    inc     h                   ; next pixel line down
    inc     de
    djnz    wrchr31
    ret

oswrch:
    push    af
    push    de
    push    hl
    push    bc
    call    oswrch0
    pop     bc
    pop     hl
    pop     de
    pop     af
    ret

oswrch0:
    push    af                  ; save a
    ld      a,(vduBuffPos)      ; Check queue size
    cp      0
    jr      nz, oswrch01        ; queue char if still waiting
    pop     af                  ; restore a

    cp      32
    jr      nc, oswrch1

    ld      (vduBuffCmd),a      ; store command
    sla     a                   ; Get address from vduTable
    ld      h,0
    ld      l,a
    ld      de,vduTable
    add     hl, de

    ld      a,(hl)              ; emulate ld hl,(hl)
    inc     hl
    ld      h,(hl)
    ld      l,a

    ld      a,h                 ; Check for h=0
    cp      0
    jr      z, oswrch00         ; jump to enqueue
    jp      (hl)                ; Call handler

oswrch00:                       ; we have bytes to store
    ld      a,l                 ; so store L in vduBuffPos
    ld      (vduBuffPos),a      ; then next L bytes will be stored in the buffer
    ret

oswrch01:
    dec     a                   ; decrement a
    ld      (vduBuffPos),a
    ld      h,0                 ; queue char in buffer at position a
    ld      l,a
    ld      de,vduBuffer
    add     hl,de
    pop     af                  ; restore char being written
    ld      (hl),a              ; store char

    ld      a,(vduBuffPos)      ; check buffer complete
    cp      0
    ret     nz                  ; buffer not complete

    ld      a,(vduBuffCmd)      ; check command
    cp      31                  ; We actually only implement 31
    ret     nz                  ; all others do nothing in Mode7
    ld      bc, (vduBuffer)     ; Fetch address
    ld      a,c                 ; The buffer is in reverse so we need
    ld      c,b                 ; to swap b & c to get the correct values
    ld      b,a                 ; for row & column
    jp      setPos              ; Set cursor position

oswrch1:
    bit     7,a                 ; teletext control char
    jr      z,oswrch2           ; valid ascii
    ld      a,32                ; replace with space
oswrch2:
    call    getCharDef          ; get char def for char in a
    ld      de, hl              ; set de to char pos
    call    wrchr               ; write char to current position

; move cursor right 1 char handling wrapping
teletextForward:
    ld      bc, (vCharPos)
    inc     c
    ld      a, 40
    cp      c
    jr      nz, teletextForward0    ; stop if not 32
    ld      c, 0                    ; Start new line
    jr      teletextDown0

; move cursor down 1 line, handling wrapping to top
teletextDown:
    ld      bc, (vCharPos)
teletextDown0:
    inc     b
    ld      a, 24
    cp      b
    jr      nz, teletextForward0    ; still on screen
    ld      bc, 0                   ; home cursor
teletextForward0:
    ld      (vCharPos), bc          ; Store new pos
nop:                                ; used in vdu table
    ret

teletextStartLine:
    ld      a,0                     ; Set column to 0, start of current line
    ld      (vCharPosX),a
    ret

; move cursor left 1 character, handling wrapping to prev line
teletextBackward:
    ld      bc, (vCharPos)
    dec     c                       ; up 1 line
    jp      p, teletextForward0     ; Positive so store & exit
    ld      c, 39                   ; Wrap to end of prev line
    jr      teletextUp

; move cursor up 1 line, handling wrapping to bottom
teletextUp:
    ld      bc, (vCharPos)
teletextUp0:
    dec     b
    jp      p, teletextForward0     ; Positive so store & exit
    ld      b, 23                   ; move to bottom line
    jr      teletextForward0        ; store & exit

; writeString writes the string at hl to the screen.
; The string is terminated by a 0 but if we have a vdu sequence then 0 is valid
; inside that sequence
writeString:
    ld      a, (hl)                 ; Get char
    cp      0
    jr      nz, writeString0        ; Not null so do nothing
    ld      a, (vduBuffPos)         ; Check queue size
    cp      0
    ret     z                       ; queue is empty so exit
    ld      a, 0                    ; we want the null in the stream
writeString0:
    call    oswrch                  ; write character
    inc     hl                      ; next char
    jr      writeString             ; loop

vduTable:
    defw nop                ; 00 NUL does nothing
    defw 1                  ; 01 SOH Send next char to printer only
    defw nop                ; 02 STX Start print job
    defw nop                ; 03 ETX End print job
    defw nop                ; 04 EOT Write text at text cursor
    defw nop                ; 05 ENQ Write text at graphics cursor
    defw nop                ; 06 ACK Enable VDU drivers
    defw nop                ; 07 BEL Make a short beep
    defw teletextBackward   ; 08 BS  Backspace cursor one character
    defw teletextForward    ; 09 HT  Advance cursor one character
    defw teletextDown       ; 0A LF  Move cursor down one line
    defw teletextUp         ; 0B VT  Move cursor up one line
    defw clearScreen        ; 0C FF  Clear text area
    defw teletextStartLine  ; 0D CR  Move cursor to start of current line
    defw nop                ; 0E SO  Page mode on
    defw nop                ; 0F SI  Page mode off
    defw nop                ; 10 DLE Clear graphics area
    defw 1                  ; 11 DC1 Define text colour
    defw 2                  ; 12 DC2 Define graphics colour
    defw 5                  ; 13 DC3 Define logical colour
    defw nop                ; 14 DC4 Restore default logical colours
    defw nop                ; 15 NAK Disable VDU drivers or delete current line
    defw 1                  ; 16 SYN Select screen mode
    defw 9                  ; 17 ETB Define display character & other commands
    defw 8                  ; 18 CAN Define graphics window
    defw 5                  ; 19 EM  Plot K,x,y
    defw nop                ; 1A SUB Restore default windows
    defw nop                ; 1B ESC Does nothing
    defw 4                  ; 1C FS  Define text window
    defw 4                  ; 1D GS  Define graphics origin
    defw teletextHome       ; 1E RS  Home text cursor to top left
    defw 2                  ; 1F US  Move text cursor to x,y

#include "charset1.z80"
;#include "debug.z80"
