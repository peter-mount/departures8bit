; ----------------------------------------------------------------------
; Screen manipulation routines for the Spectrum
; ----------------------------------------------------------------------

vCharPos:                       ; row, col coordinates in our 40x24 screen
vCharPosX:  defb 0              ; column
vCharPosY:  defb 0              ; row
vTextPos:   defw 0              ; position of vCharPos in textScreen
vAttrPos:   defw 0              ; position of vCharPos in attr_start
vCharTemp:  defw 0,0,0,0        ; 8 bytes to hold generated characters, e.g. graphics or double height
vduBuffCmd: defb 0              ; Byte invoking vduBuffer
vduBuffPos: defb 0              ; Position in vduBuffer, 0=empty
vduBuffer:  defw 0,0,0,0,0      ; 10 byte buffer for vdu sequences
tempCol:    defb 0              ; colour in refreshLineColour
textScreen  equ  &ba00          ; 1K for text screen

clearScreen:
    ld      hl,&4000            ; Start of screen memory
    ld      (hl),&00            ; Set first byte to 0
    ld      de,&4001            ; Destination as next byte
    ld      bc, 32*24*8-1       ; Number of bytes to copy
    ldir                        ; Copy from hl to de bc times

    ld      hl,&5800            ; Reset screen attributes
    ld      (hl),&07            ; White text black Background
    ld      de,&5801
    ld      bc, 32*24-1         ; Bytes to copy
    ldir

    ld      a,0                 ; Set border to black
    ld      (&5C48),a           ; set OS copy of colour
    out     (&fe),a             ; set hardware colour

    ld      a,0                 ; reset state
    ld      (vduBuffPos),a

    ld      hl, textScreen      ; Clear text screen
    ld      (hl), 32            ; with spaces
    ld      de, textScreen+1
    ld      bc, 40*24-1
    ldir

teletextHome:                   ; Home cursor to 0,0
    ld      bc, 0

setPos:                             ; Set cursor to bc (row, col)
    ld      (vCharPos),bc           ; Store in vCharPos
    call    getTextScreenPos0
    add     hl,bc                   ; b is 0 now so just add c to get column
    ld      (vTextPos),hl           ; Store hl
    ret

; Set HL to be the address in attr_start of the start of the current line.
getVattrPos:
    ld      bc,(vCharPos)           ; Get text pos
    ld      hl, attr_start          ; Calculate pos on screen
    ld      de, 32                  ; row size
    jr      calcLineStartAddr       ; Calculate line start

; Set HL to be the address in textScreen of the start of the current line.
getTextScreenPos:
    ld      bc,(vCharPos)           ; Get text pos
getTextScreenPos0:                  ; entry point for setPos as bc already set
    ld      hl, textScreen          ; Calculate pos on screen
    ld      de, 40                  ; row size
; Calculate line start address
; Entry:
;   BC      position of char B=row, C=column (unused)
;   HL      screen start address
;   DE      row length
; Exit:
;   HL      address of start of line
;   DE      unchanged
;   BC      B=0, C unchanged
calcLineStartAddr:                  ; BC=pos, HL=start addr, DE=row size
    ld      b,a                     ; check we are not on top row
    cp      0
    ret     z                       ; skip rows
calcLineStartAddr1:
    add     hl,de
    djnz    calcLineStartAddr1      ; add 40 for each row
    ret

attrOffsets:    ; offsets of attribute for each 40x char in a 32x array
    ; for i in $(seq 0 39);do printf "%d," $((i*3/4));done
    defb    0,0,1,2,3,3,4,5,6,6,7,8,9,9
    defb    10,11,12,12,13,14,15,15,16
    defb    17,18,18,19,20,21,21,22,23
    defb    24,24,25,26,27,27,28,29
; Refreshes the colours for the current line
refreshLineColour:
    call    getVattrPos             ; HL = start of line in attributes
    ld      (vAttrPos),hl           ; set vAttrPos

    call    getTextScreenPos        ; HL = textScreenPos for start of line

    ld      a, &07                  ; default colour
    ld      (tempCol),a

    ld      b,40                    ; 40 chars to scan
    ld      c,0                     ; column in line
rlc1:
    ld      a,(hl)                  ; Char to check
    cp      128
    jr      nc, rlc2
    ;bit     7,a
    ;jr      nz, rlc2
    cp      160                     ; 160+ are graphics
    jr      nc, rlc2                ; so skip
    and     &0f                     ; lower nibble of command
    cp      8                       ; >=8 ignore
    jr      nc, rlc2
    ld      a,d                     ; save
    ld      a,(tempCol)
    and     &f8                     ; mask out text colour
    or      d                       ; mask in new colour
    ld      (tempCol),a              ; set new colour

rlc2:
    push    hl                      ; Save HL & BC
    push    bc

    ld      b,0                     ; HL = attrOffsets + C
    ld      hl,attrOffsets
    add     hl,bc

    ld      a,(hl)                  ; Get true byte offset of attribute
    ld      c,a

    ld      hl,(vAttrPos)           ; HL = attr at start of line
    add     hl,bc                   ; Add offset
    ld      a,(tempCol)             ; set colour
    ld      (hl),a

    pop     bc                      ; restore bc & hl
    pop     hl

    inc     hl                      ; next char
    inc     c
    djnz    rlc1                    ; loop until end of line
    ret

; Calculates the actual bitmap address for a character in BC (row,col) into HL.
;
; Although the memory map for the spectrum screen seems weird with it's layout,
; it's actually pretty logical. You can tell this weirdness is down to how the ULA works internally.
;
; Address format:
;           H       L
;       010rrnnn rrrccccc       where r=row, c=column & n is the byte of the character definition.
;
; So, to calculate the address of a character
;       High byte = &40 or (row and &18)
;       Low byte  = (row<<5) or column
;
; That would then be the top byte of the character. To get the next byte just increment the high byte
; (e.g. n=1) & so on.
;
; Entry:
;   BC      b=row, c=col in Spectrum 32x24 characters
; Exit:
;   HL      address of top row if character definition in screen
;   BC      unchanged
getSpectrumCharPos:             ; Get Spectrum char pos (bc) into HL for physical screen address
    ld      a, b                ; first calculate high byte - get row
    and     &18                 ; Mask bits 4 & 5 from row
    or      &40                 ; set bit 6, this gives us the upper memory address
    ld      h, a                ; Set H

    ld      a, b                ; get row
    sla     a                   ; Shift left 5 to form low address
    sla     a
    sla     a
    sla     a
    sla     a                   ; HA is now the address of the start of line

    or      c                   ; Add column value
    ld      l, a                ; HL now address of top row of character

    ret

; Given an ascii char 32..127 in A return the address of the bitmap definition for that character in HL
;
; Entry:
;   A   Ascii char to retrieve, in range 32..127 inclusive
; Exit:
;   HL  Address of char definition
;   A   undefined
;   BC  undefined
getCharDef:                 ; Set's HL to be the character definition in A
    sub     32              ; char set starts with space
    ld      l,a             ; Set L to A
    ld      h,0             ; Clear H
    sla     l               ; Shift left 3 times so hl = a*8
    rl      h
    sla     l
    rl      h
    sla     l
    rl      h
    ld      bc, charset     ; Add charset base
    add     hl, bc
    ret

; move cursor back 1 character & delete it
teletextDelete:
    call    teletextBackward        ; move back 1 char
    ld      a,32                    ; replace char under cursor with space
    ld      hl,(vTextPos)           ; in the textScreen
    ld      (hl),a                  ; fall through to wrcharA

; With a ascii character in A, write the character at position vCharPos (40x24)
; handling any conversion to the Spectrum's 32x24 screen
;
; Entry:
;   A       Ascii char to write, in range 32..127 inclusive
; Exit:
;   A       undefined
;   BC      undefined
;   DE      undefined
;   HL      undefined
wrcharA:
    call    getCharDef          ; get char def for char in a
    ld      de, hl              ; set de to char pos

; With a character definition in DE, write the character at position vCharPos (40x24)
; handling any conversion to the Spectrum's 32x24 screen
;
; Entry:
;   DE      char definition to write
; Exit:
;   A       undefined
;   BC      undefined
;   DE      undefined
;   HL      undefined
wrchrDE:
    ld      bc, (vCharPos)      ; Get char position in 40x24 coordinates
    srl     c                   ; Divide column by 4
    srl     c
    ld      a,c                 ; A=c
    add     a,c
    add     a,c                 ; A = 3 * c
    ld      c,a                 ; C is now int(c*3/4) so points to start of the 3 char block
    call    getSpectrumCharPos  ; convert BC (now in 32x24 coords) into HL

    ld      b, 8                ; Set b as counter of 8 bytes to copy

    ld      a, (vCharPosX)      ; Now work out which char we are working on
    bit     1,a
    jr      nz, wrchr23         ; Chars 2 or 3
    bit     0,a                 ; Test we are char 0 or 1
    jr      nz, wrchr1          ; Char 1

wrchr0:                         ; Write char 0 in the block
    ld      a,(hl)              ; char is split across 2 bytes so byte 0
    and     &03                 ; mask out space for new char
    ld      c,a                 ; save in c
    ld      a, (de)             ; Get char definition
    sla     a                   ; Shift left 2
    sla     a
    or      c                   ; bring in next char in bottom 2 bits
    ld      (hl),a              ; store on screen
    inc     h                   ; next pixel line down
    inc     de
    djnz    wrchr0
    ret

wrchr1:                         ; write char 1 in the block
    ld      a,(hl)              ; first byte bottom 2 bits are high 2 bits of char
    and     &fc                 ; mask out those bits
    ld      c,a
    ld      a, (de)             ; char definition
    srl     a                   ; shift right 4 so we have just the top 2 bits
    srl     a
    srl     a
    srl     a
    or      c
    ld      (hl),a              ; Update screen

    inc     l                   ; now for byte 1
    ld      a,(hl)
    and     &0f                 ; mask out space for new char
    ld      c,a                 ; save in c
    ld      a, (de)             ; Get char definition
    sla     a                   ; Shift left 4
    sla     a
    sla     a
    sla     a
    or      c                   ; bring in next char in bottom 4 bits
    ld      (hl),a              ; store on screen
    dec     l                   ; restore l for next row

    inc     h
    inc     de
    djnz    wrchr1
    ret

wrchr23:                        ; See if we are char 2 or 3
    bit     0,a
    jr      nz, wrchr3          ; Char 3

wrchr2:                         ; write char 2 in the block
    inc     l                   ; Starts in byte 1
wrchr21:
    ld      a,(hl)              ; second byte bottom 4 bits are high 4 bits of char
    and     &f0                 ; mask out those bits
    ld      c,a
    ld      a, (de)             ; char definition
    srl     a                   ; shift right 2 so we have just the top 4 bits
    srl     a
    or      c
    ld      (hl),a              ; Update screen

    inc     l                   ; now for byte 1
    ld      a,(hl)
    and     &3f                 ; mask out space for new char
    ld      c,a                 ; save in c
    ld      a, (de)             ; Get char definition
    sla     a                   ; Shift left 6
    sla     a
    sla     a
    sla     a
    sla     a
    sla     a
    or      c                   ; bring in next char in bottom 4 bits
    ld      (hl),a              ; store on screen
    dec     l                   ; restore l for next row

    inc     h
    inc     de
    djnz    wrchr21
    ret

wrchr3:                         ; Write char 3 in the block
    inc     l                   ; Work on byte 2 only
    inc     l
wrchr31:
    ld      a, (hl)
    and     &c0                 ; mask out space for new char
    ld      c,a                 ; save in c
    ld      a, (de)             ; char definition
    or      c                   ; bring in prev char in top 2 bits
    ld      (hl),a              ; store on screen
    inc     h                   ; next pixel line down
    inc     de
    djnz    wrchr31
    ret

; Write character to screen at current pos, advancing cursor as required & handling BBC VDU sequences
;
; Entry:
;   A       Character to write
; Exit:
;   A       Unchanged
;   BC      Unchanged
;   DE      Unchanged
;   HL      Unchanged
oswrch:
    push    af
    push    de
    push    hl
    push    bc
    call    oswrch0
    pop     bc
    pop     hl
    pop     de
    pop     af
    ret

oswrch0:
    push    af                  ; save a
    ld      a,(vduBuffPos)      ; Check buffer size
    cp      0
    jr      nz, oswrch01        ; queue char if still waiting for content
    pop     af                  ; restore a

    cp      32                  ; Check for control codes 0..31
    jr      nc, oswrch1         ; no then treat as text

    ld      (vduBuffCmd),a      ; store command
    sla     a                   ; Get address from vduTable
    ld      h,0
    ld      l,a
    ld      de,vduTable
    add     hl, de

    ld      a,(hl)              ; emulate ld hl,(hl)
    inc     hl
    ld      h,(hl)
    ld      l,a

    ld      a,h                 ; Check for h=0 which indicates a length
    cp      0                   ; & not a handler address
    jr      z, oswrch00         ; jump to enqueue
    jp      (hl)                ; Call handler

oswrch00:                       ; we have bytes to store
    ld      a,l                 ; so store L in vduBuffPos
    ld      (vduBuffPos),a      ; then next L bytes will be stored in the buffer
nop:                            ; used in vduTable for a NOP
    ret

oswrch01:                       ; we need to store the data in the vdu buffer
    dec     a                   ; decrement a which is already set to the buffer size
    ld      (vduBuffPos),a      ; store new position
    ld      h,0                 ; queue char in buffer at position a
    ld      l,a
    ld      de,vduBuffer
    add     hl,de
    pop     af                  ; restore char being written
    ld      (hl),a              ; store char in buffer

    ld      a,(vduBuffPos)      ; check buffer complete
    cp      0
    ret     nz                  ; buffer not complete

    ld      a,(vduBuffCmd)      ; check command
    cp      31                  ; We actually only implement 31
    ret     nz                  ; all others do nothing in BBC Mode7
    ld      bc, (vduBuffer)     ; Fetch address
    ld      a,c                 ; The buffer is in reverse so we need
    ld      c,b                 ; to swap b & c to get the correct values
    ld      b,a                 ; for row & column
    jp      setPos              ; Set cursor position

oswrch1:                        ; Handle text codes
    cp      127                 ; Check for delete
    jp      z, teletextDelete

    ld      hl,(vTextPos)       ; store char in textScreen
    ld      (hl),a

    bit     7,a                 ; teletext control char
    jr      z,oswrch2           ; valid ascii
    call    refreshLineColour   ; refresh colours on this line
    ld      a,32                ; replace with space for rendering
oswrch2:
    call    wrcharA             ; write char to current position

; move cursor right 1 char handling wrapping
teletextForward:
    ld      bc, (vCharPos)
    inc     c
    ld      a, 40
    cp      c
    jp      nz, setPos              ; stop if not 32
    ld      c, 0                    ; Start new line
    jr      teletextDown0

; move cursor down 1 line, handling wrapping to top
teletextDown:
    ld      bc, (vCharPos)
teletextDown0:
    inc     b
    ld      a, 24
    cp      b
    jp      nz, setPos              ; still on screen
    jp      teletextHome            ; home cursor

teletextStartLine:
    ld      bc,(vCharPos)           ; Set column to 0, start of current line
    ld      c,0
    jp      setPos

; move cursor left 1 character, handling wrapping to prev line
teletextBackward:
    ld      bc, (vCharPos)
    dec     c                       ; up 1 line
    jp      p, setPos               ; Positive so store & exit
    ld      c, 39                   ; Wrap to end of prev line
    jr      teletextUp0

; move cursor up 1 line, handling wrapping to bottom
teletextUp:
    ld      bc, (vCharPos)
teletextUp0:
    dec     b
    jp      p, setPos               ; Positive so store & exit
    ld      b, 23                   ; move to bottom line
    jp      setPos                  ; store & exit

; writeString writes the string at hl to the screen.
; The string is terminated by a 0 but if we have a vdu sequence then 0 is valid
; inside that sequence
writeString:
    ld      a, (hl)                 ; Get char
    cp      0
    jr      nz, writeString0        ; Not null so do nothing
    ld      a, (vduBuffPos)         ; Check queue size
    cp      0
    ret     z                       ; queue is empty so exit
    ld      a, 0                    ; we want the null in the stream
writeString0:
    call    oswrch                  ; write character
    inc     hl                      ; next char
    jr      writeString             ; loop

; Lookup table for handling BBC VDU codes.
; Each entry represents a control character between 0 & 31.
; It's either the address of a routine to handle it, or the number of
; additional characters required before handling that sequence.
vduTable:
    defw nop                ; 00 NUL does nothing
    defw 1                  ; 01 SOH Send next char to printer only
    defw nop                ; 02 STX Start print job
    defw nop                ; 03 ETX End print job
    defw nop                ; 04 EOT Write text at text cursor
    defw nop                ; 05 ENQ Write text at graphics cursor
    defw nop                ; 06 ACK Enable VDU drivers
    defw nop                ; 07 BEL Make a short beep
    defw teletextBackward   ; 08 BS  Backspace cursor one character
    defw teletextForward    ; 09 HT  Advance cursor one character
    defw teletextDown       ; 0A LF  Move cursor down one line
    defw teletextUp         ; 0B VT  Move cursor up one line
    defw clearScreen        ; 0C FF  Clear text area
    defw teletextStartLine  ; 0D CR  Move cursor to start of current line
    defw nop                ; 0E SO  Page mode on
    defw nop                ; 0F SI  Page mode off
    defw nop                ; 10 DLE Clear graphics area
    defw 1                  ; 11 DC1 Define text colour
    defw 2                  ; 12 DC2 Define graphics colour
    defw 5                  ; 13 DC3 Define logical colour
    defw nop                ; 14 DC4 Restore default logical colours
    defw nop                ; 15 NAK Disable VDU drivers or delete current line
    defw 1                  ; 16 SYN Select screen mode
    defw 9                  ; 17 ETB Define display character & other commands
    defw 8                  ; 18 CAN Define graphics window
    defw 5                  ; 19 EM  Plot K,x,y
    defw nop                ; 1A SUB Restore default windows
    defw nop                ; 1B ESC Does nothing
    defw 4                  ; 1C FS  Define text window
    defw 4                  ; 1D GS  Define graphics origin
    defw teletextHome       ; 1E RS  Home text cursor to top left
    defw 2                  ; 1F US  Move text cursor to x,y

#include "charset1.z80"
;#include "debug.z80"
