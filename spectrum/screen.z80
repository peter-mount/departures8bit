; ----------------------------------------------------------------------
; Screen manipulation routines for the Spectrum
; ----------------------------------------------------------------------

vCharPos:                       ; row, col coordinates in our 40x24 screen
vCharPosX:  defb 0              ; column
vCharPosY:  defb 0              ; row

vCharAddr:  defw 0          ; address of vCharPos
vCharTemp:  defw 0,0,0,0    ; Workspace of 3 8 byte characters
            defw 0,0,0,0
            defw 0,0,0,0

clearScreen:
    ld      hl,&4000            ; Start of screen memory
    ld      (hl),&00            ; Set first byte to 0
    ld      de,&4001            ; Destination as next byte
    ld      bc, 32*24*8-1       ; Number of bytes to copy
    ldir                        ; Copy from hl to de bc times

    ld      hl,&5800            ; Reset screen attributes
    ld      (hl),&07            ; White text black Background
    ld      de,&5801
    ld      bc, 32*24-1         ; Bytes to copy
    ldir

    ld      a,0                 ; Set border to black
    ld      (&5C48),a           ; set OS copy of colour
    out     (&fe),a             ; set hardware colour

homeCursor:                     ; Home cursor to 0,0
    ld      bc, 0

setPos:                         ; Set cursor to bc (row, col)
    ld      (vCharPos),bc       ; Store in vCharPos
    ret

; Calculates the actual bitmap address for a character in BC (row,col) into HL.
;
; Although the memory map for the spectrum screen seems weird with it's layout,
; it's actually pretty logical. You can tell this weirdness is down to how the ULA works internally.
;
; Address format:
;           H       L
;       010rrnnn rrrccccc       where r=row, c=column & n is the byte of the character definition.
;
; So, to calculate the address of a character
;       High byte = &40 or (row and &18)
;       Low byte  = (row<<5) or column
;
; That would then be the top byte of the character. To get the next byte just increment the high byte
; (e.g. n=1) & so on.
;
getSpectrumCharPos:             ; Get Spectrum char pos (bc) into HL for physical screen address
    ld      a, b                ; first calculate high byte - get row
    and     &18                 ; Mask bits 4 & 5 from row
    or      &40                 ; set bit 6, this gives us the upper memory address
    ld      h, a                ; Set H

    ld      a, b                ; get row
    sla     a                   ; Shift left 5 to form low address
    sla     a
    sla     a
    sla     a
    sla     a                   ; HA is now the address of the start of line

    or      c                   ; Add column value
    ld      l, a                ; HL now address of top row of character

    ret

; Given an ascii char 32..127 in A return the address of the bitmap definition for that character in HL
getCharDef:                 ; Set's HL to be the character definition in A
    sub     32              ; char set starts with space
    ld      l,a             ; Set L to A
    ld      h,0             ; Clear H
    sla     l               ; Shift left 3 times so hl = a*8
    rl      h
    sla     l
    rl      h
    sla     l
    rl      h
    ld      bc, charset     ; Add charset base
    add     hl, bc
    ret

; With a character definition in DE, write the character at position vCharPos (40x24)
; handling any conversion to the Spectrum's 32x24 screen
wrchr:
    ld      bc, (vCharPos)      ; Get char position in 40x24 coordinates
    srl     c                   ; Divide column by 4
    srl     c
    ld      a,c                 ; A=c
    add     a,c
    add     a,c                 ; A = 3 * c
    ld      c,a                 ; C is now int(c*3/4) so points to start of the 3 char block
    call    getSpectrumCharPos  ; convert BC (now in 32x24 coords) into HL

    ld      b, 8                ; Set b as counter of 8 bytes to copy

    ld      a, (vCharPosX)      ; Now work out which char we are working on
    bit     1,a
    jr      nz, wrchr23         ; Chars 2 or 3
    bit     0,a                 ; Test we are char 0 or 1
    jr      nz, wrchr1          ; Char 1

wrchr0:                         ; Write char 0 in the block
    ld      a,(hl)              ; char is split across 2 bytes so byte 0
    and     &03                 ; mask out space for new char
    ld      c,a                 ; save in c
    ld      a, (de)             ; Get char definition
    sla     a                   ; Shift left 2
    sla     a
    or      c                   ; bring in next char in bottom 2 bits
    ld      (hl),a              ; store on screen
    inc     h                   ; next pixel line down
    inc     de
    djnz    wrchr0
    ret

wrchr1:                         ; write char 1 in the block
    ld      a,(hl)              ; first byte bottom 2 bits are high 2 bits of char
    and     &fc                 ; mask out those bits
    ld      c,a
    ld      a, (de)             ; char definition
    srl     a                   ; shift right 4 so we have just the top 2 bits
    srl     a
    srl     a
    srl     a
    or      c
    ld      (hl),a              ; Update screen

    inc     l                   ; now for byte 1
    ld      a,(hl)
    and     &0f                 ; mask out space for new char
    ld      c,a                 ; save in c
    ld      a, (de)             ; Get char definition
    sla     a                   ; Shift left 4
    sla     a
    sla     a
    sla     a
    or      c                   ; bring in next char in bottom 4 bits
    ld      (hl),a              ; store on screen
    dec     l                   ; restore l for next row

    inc     h
    inc     de
    djnz    wrchr1
    ret

wrchr23:                        ; See if we are char 2 or 3
    bit     0,a
    jr      nz, wrchr3          ; Char 3

wrchr2:                         ; write char 2 in the block
    inc     l                   ; Starts in byte 1
wrchr21:
    ld      a,(hl)              ; second byte bottom 4 bits are high 4 bits of char
    and     &f0                 ; mask out those bits
    ld      c,a
    ld      a, (de)             ; char definition
    srl     a                   ; shift right 2 so we have just the top 4 bits
    srl     a
    or      c
    ld      (hl),a              ; Update screen

    inc     l                   ; now for byte 1
    ld      a,(hl)
    and     &3f                 ; mask out space for new char
    ld      c,a                 ; save in c
    ld      a, (de)             ; Get char definition
    sla     a                   ; Shift left 6
    sla     a
    sla     a
    sla     a
    sla     a
    sla     a
    or      c                   ; bring in next char in bottom 4 bits
    ld      (hl),a              ; store on screen
    dec     l                   ; restore l for next row

    inc     h
    inc     de
    djnz    wrchr21
    ret

wrchr3:                         ; Write char 3 in the block
    inc     l                   ; Work on byte 2 only
    inc     l
wrchr31:
    ld      a, (hl)
    and     &c0                 ; mask out space for new char
    ld      c,a                 ; save in c
    ld      a, (de)             ; char definition
    or      c                   ; bring in prev char in top 2 bits
    ld      (hl),a              ; store on screen
    inc     h                   ; next pixel line down
    inc     de
    djnz    wrchr31
    ret

testText:
    ld      bc, &0400           ; Start at 8,0
    call    setPos
    ld      a, 32               ; Set A to 32 (space)
testText1:
    call    oswrch              ; write char
    inc     a
    bit     7,a
    jr      z, testText1        ; Loop until we hit 128
    ret

oswrch:
    push    af
    push    de
    push    hl
    push    bc
    call    getCharDef          ; get char def for char in a
    ld      de, hl              ; set de to char pos

    ;ld      bc,(vCharPos)       ; bc = vCharPos (row,col) in spectrum coordinates
    ;call    getSpectrumCharPos  ; returns hl = screen address
    call    wrchr

    ;call    PR_ALL              ; 8x8 print

    ld      bc, (vCharPos)      ; inc x
    inc     c
    ld      a, 40
    cp      c
    jr      nz, oswrch0         ; stop if not 32
    ld      c, 0
    inc     b
    ld      a, 24
    cp      b
    jr      nz, oswrch0         ; still on screen
    ld      bc, 0               ; home cursor
oswrch0:
    ld      (vCharPos), bc      ; Store new pos
oswrch1:
    pop     bc
    pop     hl
    pop     de
    pop     af
    ret

; Write all chars 32-127 inclusive to screen as 8x8 characters
testChars:
    ld hl, &4000        ; Screen location
    ld de, charset      ; '0' in charset
    ld a, 128-32        ; Number of chars to output
l1:
    push af             ; Save A
    call PR_ALL         ; Write character
    pop af              ; Restore a
    dec a               ; dec & loop until we hit 0
    jr nz, l1
    ret

; ----------------------------------
; THE 'PRINT ALL CHARACTERS' ROUTINE
; ----------------------------------
;   This entry point entered from above to print ASCII and UDGs but also from
;   earlier to print mosaic characters.
;   HL=destination
;   DE=character source
;   BC=line/column

PR_ALL: PUSH    HL              ; and destination
        LD      A,$08           ; prepare to count 8 bytes
        EX      DE,HL           ; now HL=source, DE=destination
PRALL1: EX      AF,AF'          ; save byte count
        ;LD      A,(DE)          ; fetch existing destination byte
        ;AND     B               ; consider OVER
        ;XOR     (HL)            ; now XOR with source
        ;XOR     C               ; now with INVERSE MASK
        LD      A,(HL)
        LD      (DE),A          ; update screen/printer
        EX      AF,AF'          ; restore byte count

        INC     D               ; gives next pixel line down screen

        INC     HL              ; address next character byte
        DEC     A               ; the byte count is decremented
        JR      NZ,PRALL1       ; loop until all 8 bytes completed

        EX      DE,HL           ; destination to HL
        DEC     H               ; bring back to last updated screen position
        ;BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?
        ;CALL    Z,L0BDB         ; if not, call routine PO-ATTR to update
                                ; corresponding colour attribute.
        POP     HL              ; restore original screen/printer position
        INC     HL              ; increase screen/printer position
        RET                     ; return and continue into PO-STORE
                                ; within PO-ABLE

testChars1:
    ld hl,charset
    ld de,&4000
    ld bc, 768
    ldir
    ret

#include "charset1.z80"
